<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git（分布式版本控制系统）基本操作]]></title>
    <url>%2F2018%2F11%2F08%2Fgit%2F</url>
    <content type="text"><![CDATA[初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步：1.使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件；2.使用命令git commit -m &lt;message&gt;，完成。 git status命令可以让我们时刻掌握仓库当前的状态,用git diff这个命令看具体修改了什么内容。 提交修改和提交新文件是一样的两步，第一步是git add &lt;file&gt;,然后可以运行git status看看当前仓库的状态,第二步是git commit &lt;message&gt;。 用git log命令查看提交历史记录，commit后面表示版本号的id。 如何回到前面的版本：使用git reset --hard HEAD^命令，回到上一个版本。在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本可以写成HEAD~100；也可以通过$ git reset --hard &lt;版本号id&gt;，版本号id可以不用写全，写前面几位git会自动查找。 Git提供了一个命令git reflog用来记录你的每一次命令，可以查看commit提交信息和head版本id。 如果不用git add到暂存区，那就不会加入到commit中。 想直接丢弃工作区的修改时，用命令 git checkout -- &lt;file&gt;。 当文件添加到了暂存区，想丢弃修改时，第一步用命令git reset HEAD &lt;file&gt;，第二步用命令 git checkout -- &lt;file&gt;。 命令git rm &lt;file&gt;用于删除一个文件。 创建SSH Key:ssh-keygen -t rsa -C &quot;youremail@example.com&quot;，然后可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容，然后“Add Key”即可。本地仓库与GitHub仓库关联，使用git remote add origin +GitHub仓库ssh地址，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的。把本地库的内容推送到远程，用git push命令。第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令，git push -u origin master。 查看远程库信息，使用git remote -v。 创建分支：git branch &lt;name&gt;。 git branch命令列出所有分支，当前分支前面会标一个*号。 切换分支：git checkout &lt;name&gt;。 创建+切换分支：git checkout -b &lt;name&gt;。 合并某分支到当前分支：git merge &lt;name&gt;。 删除分支：git branch -d &lt;name&gt;。 git stash可以把当前工作现场“储藏”起来,git stash pop回到工作现场恢复的同时把stash内容也删了。 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。 git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id。 git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息。 git tag可以查看所有标签。 git push origin &lt;tagname&gt;可以推送一个本地标签。 git push origin --tags可以推送全部未推送过的本地标签 git tag -d &lt;tagname&gt;可以删除一个本地标签 git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件之间传值]]></title>
    <url>%2F2018%2F10%2F31%2Fvuecomponent%2F</url>
    <content type="text"><![CDATA[父组件向子组件传值若父组件中的值value1:&#39;这是父组件中的值&#39;，要向子组件test传值。则在父组件中&lt;test v-bind:parentValue=&quot;value1&quot;&gt;&lt;/test&gt;上绑定自定义属性名（parentValue）的值为value1；子组件中data下定义props的值为父组件里自定义的属性名（parentValue），即：props:[&#39;parentValue&#39;]，然后在子组件中就可以通过parentValue传递父组件的值了。 子组件向父组件传递数据子组件主要通过事件传递数据给父组件,先在子组件中demo绑定事件（test），在methods中通过:123test:function()&#123; this.$emit(&apos;父组件中绑定的接收方法parentMethod&apos;,this.要传递的数据） &#125; 在父组件中通过&lt;demo v-on:parentMethod=&quot;自定义获取数据的方法getValue&quot;&gt;&lt;/demo&gt;，在父组件中methods里实现方法getValue(val){ this.value=val},其中里面的val是形参，再data中return接收到的数据value:&#39; &#39;，这时候就可以在父组件中使用value来传递子组件中的数据了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ajax相关问题]]></title>
    <url>%2F2018%2F10%2F12%2Fajax%2F</url>
    <content type="text"><![CDATA[Ajax可以使网页实现异步更新，能够在不重新加载整个网页的情况下，对网页的某部分进行更新。就是利用JavaScript执行异步网络请求的方法。 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象，对于低版本的IE，需要用ActiveXObject对象。 如果想把标准写法和IE写法混在一起，可以这么写:123456 var request; if (window.XMLHttpRequest) &#123; request = new XMLHttpRequest(); &#125; else &#123; request = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);&#125; jQuery中封装了ajax操作：$.ajax()属于最底层的方法（接收的参数）；1.url:要求为String类型的参数，（默认为当前页地址）发送请求的地址。 2.type:要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。 3.timeout:要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。 4.async:要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。 5.cache:要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。 6.data:要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看 processData选项。对象必须为key/value格式，例如{foo1:”bar1”,foo2:”bar2”}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[“bar1”,”bar2”]}转换为&amp;foo=bar1&amp;foo=bar2。 7.dataType:要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：xml：返回XML文档，可用JQuery处理。html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。json：返回JSON数据。jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。text：返回纯文本字符串。 8.beforeSend：要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。123function(XMLHttpRequest)&#123; this; //调用本次ajax请求时传递的options参数 &#125; 9.complete：要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。123function(XMLHttpRequest, textStatus)&#123; this; //调用本次ajax请求时传递的options参数 &#125; 10.success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。 (1)由服务器返回，并根据dataType参数进行处理后的数据。 (2)描述状态的字符串。1234function(data, textStatus)&#123; //data可能是xmlDoc、jsonObj、html、text等等 this; //调用本次ajax请求时传递的options参数 &#125; 11.error:要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下：1234function(XMLHttpRequest, textStatus, errorThrown)&#123; //通常情况下textStatus和errorThrown只有其中一个包含信息 this; //调用本次ajax请求时传递的options参数 &#125; 12.contentType：要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为”application/x-www-form-urlencoded”。该默认值适合大多数应用场合。 13.dataFilter：要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。1234function(data, type)&#123; //返回处理后的数据 return data; &#125; 14.dataFilter：要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。1234function(data, type)&#123; //返回处理后的数据 return data; &#125; 15.global：要求为Boolean类型的参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件。 16.ifModified：要求为Boolean类型的参数，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息。 17.jsonp：要求为String类型的参数，在一个jsonp请求中重写回调函数的名字。该值用来替代在”callback=?”这种GET或POST请求中URL参数里的”callback”部分，例如{jsonp:’onJsonPLoad’}会导致将”onJsonPLoad=?”传给服务器。 18.username：要求为String类型的参数，用于响应HTTP访问认证请求的用户名。 19.password：要求为String类型的参数，用于响应HTTP访问认证请求的密码。 20.processData：要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型”application/x-www-form-urlencoded”。如果要发送DOM树信息或者其他不希望转换的信息，请设置为false。 21.scriptCharset：要求为String类型的参数，只有当请求时dataType为”jsonp”或者”script”，并且type是GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。 load(),$.get(),$.post()属于第二层方法(接收参数）； load(url,[data].callback)；$.get(url,[data],callback,type)//post方法参数相同 $.getScript(),$.getJson()属于第三层方法(接收参数）。123456$(function()&#123; $(&quot;test&quot;).click(function()&#123; $.getScript(&apos;test.js&apos;); &#125;);&#125;)$.getJson()参数相同 Ajax跨域问题 Ajax跨域问题是因为浏览器的同源策略导致的，默认情况下，JavaScript在发送AJAX请求时，URL的域名要相同，协议要相同，端口号要相同必须和当前页面完全一致。 解决办法JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。]]></content>
  </entry>
  <entry>
    <title><![CDATA[监听移动端滑动事件]]></title>
    <url>%2F2018%2F10%2F06%2Fmobile%20slide%2F</url>
    <content type="text"><![CDATA[监听用户滑动事件1234567891011121314151617181920212223242526272829var mybody = document.getElementsByTagName(&apos;body&apos;)[0]; var startX, startY, moveEndX, moveEndY, X, Y; mybody.addEventListener(&apos;touchstart&apos;, function (e) &#123; // e.preventDefault(); startX = e.touches[0].pageX; startY = e.touches[0].pageY; &#125;, false); mybody.addEventListener(&apos;touchmove&apos;, function (e) &#123; // e.preventDefault(); moveEndX = e.changedTouches[0].pageX; moveEndY = e.changedTouches[0].pageY; X = moveEndX - startX; Y = moveEndY - startY; if (Math.abs(X) &gt; Math.abs(Y) &amp;&amp; X &gt; 0) &#123;// right alert(&apos;向右&apos;); &#125; else if (Math.abs(X) &gt; Math.abs(Y) &amp;&amp; X &lt; 0) &#123;// left alert(&apos;向左&apos;); &#125; else if (Math.abs(Y) &gt; Math.abs(X) &amp;&amp; Y &gt; 0) &#123;// down alert(&apos;向下&apos;); &#125; else if (Math.abs(Y) &gt; Math.abs(X) &amp;&amp; Y &lt; 0) &#123;// up alert(&apos;向上&apos;); &#125; else &#123;//没有发生滑动 alert(&apos;没有发生滑动&apos;); &#125; &#125;); 主要是通过touchstart和touchmove来监听用户滑动，再通过滑动的起始坐标作差的绝对值来判断是向哪个方向滑动。]]></content>
  </entry>
  <entry>
    <title><![CDATA[清除浮动的几种方式]]></title>
    <url>%2F2018%2F09%2F04%2Ffloat%2F</url>
    <content type="text"><![CDATA[说到清除浮动之前，得先了解下BFC (Block formatting context) “块级格式化上下文”，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用， 在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。如果一个元素符合了成为BFC的条件，该元素内部元素的布局和定位就和外部元素互不影响(除非内部的盒子建立了新的 BFC)，是一个隔离了的独立容器，它是一个独立的渲染区域。 形成 BFC 的条件1、浮动元素，float 除 none 以外的值；2、绝对定位元素，position（absolute，fixed）；3、display 为以下其中之一的值 inline-blocks，table-cells，table-captions；4、overflow 除了 visible 以外的值（hidden，auto，scroll）。 BFC常见作用 ： 1、包含浮动元素例如：高度塌陷问题：在通常情况下父元素的高度会被子元素撑开，而在这里因为其子元素为浮动元素所以父元素发生了高度坍塌，上下边界重合。这时就可以用bfc来清除浮动了。2、不被浮动元素覆盖例如： div浮动兄弟遮盖问题：由于一个块级元素发生了浮动，所以和一个未发生浮动的块级元素不在同一层内，所以会发生div遮挡问题。这时可以给未发生浮动的元素添加 overflow: hidden属性来触发BFC解决遮挡问题。3、 BFC 会阻止外边距折叠例如：margin塌陷问题：在标准文档流中，块级标签之间竖直方向的margin会以大的为准，这就是margin的塌陷现象。可以用overflow：hidden产生bfc来解决。 清除浮动的几种方式：1、父级div定义伪类：after和zoom。12.clearfloat:after&#123;display:block;clear:both;content:&quot;&quot;;visibility:hidden;height:0&#125; .clearfloat&#123;zoom:1&#125; 2.给元素添加clear属性，或在结尾处添加空div标签clear:both（内墙法，外墙法同理）。.clearfloat{clear:both}3.父级div定义height（只适合高度固定的布局，要给出精确的高度）。4.父级div定义overflow:hidden/auto，*zoom: 1。5.设置父元素浮动 。6.双伪元素（企业最常用）。12.cf:after，.cf:before &#123;content: &quot; &quot;; display: table;&#125;.cf:after &#123;clear: both;&#125; ：before是因为table类型能生成独立的bfc，防止上边距塌陷。：after负责清除浮动，防止父级高度塌陷；配合使用，代码少，效率高。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo+github搭建博客遇到的一些问题]]></title>
    <url>%2F2018%2F08%2F26%2Ftest%2F</url>
    <content type="text"><![CDATA[个人头像的设置问题 官方文档是这样描述的:将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在) 配置为：avatar: /uploads/avatar.png 或者 放置在 source/images/ 目录下 配置为：avatar: /images/avatar.png 而这样设置，头像却显示不出来，原来是要在站点目录的source下创建uploads文件夹，将图片放在uploads下并命名为avatar.png，然后再设置站点配置文件-config.yml，在任意位置添加avatar: /upload/image/avatar.png并保存。 添加评论系统 我使用了来必力免费的city版本，因为它支持10多种账号登录发布评论，在新版nexT主题中只需编辑主题配置文件，编辑来必力中提供的uid添加到livere-uid字段livere-uid: #your livere_uid即可。而此系统在博文前不能显示评论数量，在nexT中多个评论系统是相互冲突的，只能设置一个。最后，如需取消某个页面/文章的评论，在md文件中增加 comments: false即可。 Hexo常用快捷键 hexo clean 清除缓存 hexo n “your post name” == hexo new “your post name” 新建博文 hexo g == hexo generate 生成静态文件 hexo s == hexo server 运行hexo服务器 hexo d == hexo deploy 部署到云端]]></content>
  </entry>
</search>
