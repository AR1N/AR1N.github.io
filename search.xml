<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ajax相关问题]]></title>
    <url>%2F2018%2F10%2F12%2Fajax%2F</url>
    <content type="text"><![CDATA[Ajax可以使网页实现异步更新，能够在不重新加载整个网页的情况下，对网页的某部分进行更新。就是利用JavaScript执行异步网络请求的方法。 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象，对于低版本的IE，需要用ActiveXObject对象。 如果想把标准写法和IE写法混在一起，可以这么写:123456var request; if (window.XMLHttpRequest) &#123; request = new XMLHttpRequest(); &#125; else &#123; request = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);&#125; jQuery中封装了ajax操作：$.ajax()属于最底层的方法（接收的参数）；1.url:要求为String类型的参数，（默认为当前页地址）发送请求的地址。 2.type:要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。 3.timeout:要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。 4.async:要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。 5.cache:要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。 6.data:要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看 processData选项。对象必须为key/value格式，例如{foo1:”bar1”,foo2:”bar2”}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[“bar1”,”bar2”]}转换为&amp;foo=bar1&amp;foo=bar2。 7.dataType:要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：xml：返回XML文档，可用JQuery处理。html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。json：返回JSON数据。jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。text：返回纯文本字符串。 8.beforeSend：要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。123456 function(XMLHttpRequest)&#123; this; //调用本次ajax请求时传递的options参数 &#125;``` 9.complete：要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。 function(XMLHttpRequest, textStatus){ this; //调用本次ajax请求时传递的options参数 } 123410.success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。 (1)由服务器返回，并根据dataType参数进行处理后的数据。 (2)描述状态的字符串。 function(data, textStatus){ //data可能是xmlDoc、jsonObj、html、text等等 this; //调用本次ajax请求时传递的options参数 } 12311.error:要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下： function(XMLHttpRequest, textStatus, errorThrown){ //通常情况下textStatus和errorThrown只有其中一个包含信息 this; //调用本次ajax请求时传递的options参数 } 123456789101112.contentType：要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为&quot;application/x-www-form-urlencoded&quot;。该默认值适合大多数应用场合。13.dataFilter：要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。 ``` function(data, type)&#123; //返回处理后的数据 return data; &#125; 14.dataFilter：要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。1234function(data, type)&#123; //返回处理后的数据 return data; &#125; 15.global：要求为Boolean类型的参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件。 16.ifModified：要求为Boolean类型的参数，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息。 17.jsonp：要求为String类型的参数，在一个jsonp请求中重写回调函数的名字。该值用来替代在”callback=?”这种GET或POST请求中URL参数里的”callback”部分，例如{jsonp:’onJsonPLoad’}会导致将”onJsonPLoad=?”传给服务器。 18.username：要求为String类型的参数，用于响应HTTP访问认证请求的用户名。 19.password：要求为String类型的参数，用于响应HTTP访问认证请求的密码。 20.processData：要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型”application/x-www-form-urlencoded”。如果要发送DOM树信息或者其他不希望转换的信息，请设置为false。 21.scriptCharset：要求为String类型的参数，只有当请求时dataType为”jsonp”或者”script”，并且type是GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。 load(),$.get(),$.post()属于第二层方法(接收参数）；12```$.get(url,[data],callback,type)//post方法参数相同``` &lt;code&gt;$.getScript()&lt;/code&gt;,&lt;code&gt;$.getJson()&lt;/code&gt;属于第三层方法(接收参数）。 $(function(){ $(“test”).click(function(){ $.getScript(‘test.js’); }); }) $.getJson()参数相同` Ajax跨域问题 Ajax跨域问题是因为浏览器的同源策略导致的，默认情况下，JavaScript在发送AJAX请求时，URL的域名要相同，协议要相同，端口号要相同必须和当前页面完全一致。 解决办法JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。]]></content>
  </entry>
  <entry>
    <title><![CDATA[监听移动端滑动事件]]></title>
    <url>%2F2018%2F10%2F06%2Fmobile%20slide%2F</url>
    <content type="text"><![CDATA[监听用户滑动事件1234567891011121314151617181920212223242526272829var mybody = document.getElementsByTagName(&apos;body&apos;)[0]; var startX, startY, moveEndX, moveEndY, X, Y; mybody.addEventListener(&apos;touchstart&apos;, function (e) &#123; // e.preventDefault(); startX = e.touches[0].pageX; startY = e.touches[0].pageY; &#125;, false); mybody.addEventListener(&apos;touchmove&apos;, function (e) &#123; // e.preventDefault(); moveEndX = e.changedTouches[0].pageX; moveEndY = e.changedTouches[0].pageY; X = moveEndX - startX; Y = moveEndY - startY; if (Math.abs(X) &gt; Math.abs(Y) &amp;&amp; X &gt; 0) &#123;// right alert(&apos;向右&apos;); &#125; else if (Math.abs(X) &gt; Math.abs(Y) &amp;&amp; X &lt; 0) &#123;// left alert(&apos;向左&apos;); &#125; else if (Math.abs(Y) &gt; Math.abs(X) &amp;&amp; Y &gt; 0) &#123;// down alert(&apos;向下&apos;); &#125; else if (Math.abs(Y) &gt; Math.abs(X) &amp;&amp; Y &lt; 0) &#123;// up alert(&apos;向上&apos;); &#125; else &#123;//没有发生滑动 alert(&apos;没有发生滑动&apos;); &#125; &#125;); 主要是通过touchstart和touchmove来监听用户滑动，再通过滑动的起始坐标作差的绝对值来判断是向哪个方向滑动。]]></content>
  </entry>
  <entry>
    <title><![CDATA[清除浮动的几种方式]]></title>
    <url>%2F2018%2F09%2F04%2Ffloat%2F</url>
    <content type="text"><![CDATA[说到清除浮动之前，得先了解下BFC (Block formatting context) “块级格式化上下文”，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用， 在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。如果一个元素符合了成为BFC的条件，该元素内部元素的布局和定位就和外部元素互不影响(除非内部的盒子建立了新的 BFC)，是一个隔离了的独立容器，它是一个独立的渲染区域。 形成 BFC 的条件1、浮动元素，float 除 none 以外的值；2、绝对定位元素，position（absolute，fixed）；3、display 为以下其中之一的值 inline-blocks，table-cells，table-captions；4、overflow 除了 visible 以外的值（hidden，auto，scroll）。 BFC常见作用 ： 1、包含浮动元素例如：高度塌陷问题：在通常情况下父元素的高度会被子元素撑开，而在这里因为其子元素为浮动元素所以父元素发生了高度坍塌，上下边界重合。这时就可以用bfc来清除浮动了。2、不被浮动元素覆盖例如： div浮动兄弟遮盖问题：由于一个块级元素发生了浮动，所以和一个未发生浮动的块级元素不在同一层内，所以会发生div遮挡问题。这时可以给未发生浮动的元素添加 overflow: hidden属性来触发BFC解决遮挡问题。3、 BFC 会阻止外边距折叠例如：margin塌陷问题：在标准文档流中，块级标签之间竖直方向的margin会以大的为准，这就是margin的塌陷现象。可以用overflow：hidden产生bfc来解决。 清除浮动的几种方式：1、父级div定义伪类：after和zoom。12.clearfloat:after&#123;display:block;clear:both;content:&quot;&quot;;visibility:hidden;height:0&#125; .clearfloat&#123;zoom:1&#125; 2.给元素添加clear属性，或在结尾处添加空div标签clear:both（内墙法，外墙法同理）。.clearfloat{clear:both}3.父级div定义height（只适合高度固定的布局，要给出精确的高度）。4.父级div定义overflow:hidden/auto，*zoom: 1。5.设置父元素浮动 。6.双伪元素（企业最常用）。12.cf:after，.cf:before &#123;content: &quot; &quot;; display: table;&#125;.cf:after &#123;clear: both;&#125; ：before是因为table类型能生成独立的bfc，防止上边距塌陷。：after负责清除浮动，防止父级高度塌陷；配合使用，代码少，效率高。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo+github搭建博客遇到的一些问题]]></title>
    <url>%2F2018%2F08%2F26%2Ftest%2F</url>
    <content type="text"><![CDATA[个人头像的设置问题 官方文档是这样描述的:将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在) 配置为：avatar: /uploads/avatar.png 或者 放置在 source/images/ 目录下 配置为：avatar: /images/avatar.png 而这样设置，头像却显示不出来，原来是要在站点目录的source下创建uploads文件夹，将图片放在uploads下并命名为avatar.png，然后再设置站点配置文件-config.yml，在任意位置添加avatar: /upload/image/avatar.png并保存。 添加评论系统 我使用了来必力免费的city版本，因为它支持10多种账号登录发布评论，在新版nexT主题中只需编辑主题配置文件，编辑来必力中提供的uid添加到livere-uid字段livere-uid: #your livere_uid即可。而此系统在博文前不能显示评论数量，在nexT中多个评论系统是相互冲突的，只能设置一个。最后，如需取消某个页面/文章的评论，在md文件中增加 comments: false即可。 Hexo常用快捷键 hexo clean 清除缓存 hexo n “your post name” == hexo new “your post name” 新建博文 hexo g == hexo generate 生成静态文件 hexo s == hexo server 运行hexo服务器 hexo d == hexo deploy 部署到云端]]></content>
  </entry>
</search>
