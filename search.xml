<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue相关问题]]></title>
    <url>%2F2019%2F01%2F16%2FaboutVue%2F</url>
    <content type="text"><![CDATA[首先什么是mvvm：MVVM 是 Model-View-ViewModel的缩写。mvvm 是一种设计思想。Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑；View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来，ViewModel 是一个同步 View 和 Model 的对象。在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 vue生命周期的理解：总共分为 8 个阶段创建前/后，载入前/后，更新前/后，销毁前/后。创建前/后： 在beforeCreate 阶段，vue 实例的挂载元素 el 还没有。载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。更新前/后：当 data 变化时，会触发beforeUpdate 和 updated 方法。销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在。 vue的双向绑定的原理： vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 具体步骤： 第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。 第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。 第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:在自身实例化时往属性订阅器(dep)里面添加自己；自身必须有一个 update()方法；待属性变动 dep.notice()通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。 第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。vuex相关：有 5 种属性，分别是 state、getter、mutation、action、module。 store 特性：vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data。state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新。它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性。 getter 特性：getter 可以对 state 进行计算操作，它就是 store 的计算属性。虽然在组件内也可以做计算属性，但是 getters 可以在多给件之间复用。如果一个状态只在一个组件内使用，是可以不用 getters。 mutation 特性：action 类似于 muation, 不同在于：action 提交的是 mutation,而不是直接变更状态。action 可以包含任意异步操作。 vue组件之间的传值： 父组件向子组件传递数据 1234567891011121314151617181920212223242526272829303132//父组件通过标签上面定义传值&lt;template&gt; &lt;Main :obj=&quot;data&quot;&gt;&lt;/Main&gt;&lt;/template&gt;&lt;script&gt; //引入子组件 import Main form &quot;./main&quot; exprot default&#123; name:&quot;parent&quot;, data()&#123; return &#123; data:&quot;我要向子组件传递数据&quot; &#125; &#125;, //初始化组件 components:&#123; Main &#125; &#125;&lt;/script&gt;//子组件通过props方法接受数据&lt;template&gt; &lt;div&gt;&#123;&#123;data&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; exprot default&#123; name:&quot;son&quot;, //接受父组件传值 props:[&quot;data&quot;] &#125;&lt;/script&gt; 子组件向父组件传递数据 123456789101112131415161718192021222324252627282930//子组件通过$emit方法传递参数&lt;template&gt; &lt;div v-on:click=&quot;events&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; //引入子组件 import Main form &quot;./main&quot; exprot default&#123; methods:&#123; events:function(params)&#123; console.log(params) &#125; &#125; &#125;&lt;/script&gt;&lt;template&gt; &lt;div v-on:click=&quot;emitEvent&quot;&gt;&#123;&#123;data&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; exprot default&#123; name:&quot;son&quot;, //接受父组件传值 props:[&quot;data&quot;], methods: &#123; emitEvent() &#123; this.$emit(&apos;event&apos;, params) // 派发函数，并传递值，params是你自己想传的值 &#125; &#125; &#125;&lt;/script&gt; 默认显示子路由：1234567routes: [ &#123;path: &apos;/&apos;, name: &apos;home&apos;, component: home, children: [&#123; path: &apos;/echarts&apos;, name: &apos;echarts&apos;, component: echarts &#125;, &#123; path: &apos;/index&apos;, name: &apos;index&apos;,component: index&#125;],redirect:&apos;/index&apos; &#125;] &#125;] //通过redirect:&apos;/index&apos; 默认显示index Vue中使用echarts：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123 &lt;template&gt;&lt;!-- 定义一个承载容器 --&gt; &lt;div id=&quot;chartshow&quot; style=&quot; height:500px;&quot;&gt;&lt;/div&gt; &lt;/template&gt;&lt;script&gt;import echarts from &quot;echarts&quot;; //引入echarts //此外在main.js中还需要再引入echarts ,并按照官方的方式Vue.prototype.$echarts = echarts 使用.export default &#123; data() &#123; return &#123; chartshow: null &#125;; &#125;, methods: &#123; drawshowChart() &#123; this.chartshow = echarts.init(document.getElementById(&quot;chartshow&quot;)); this.chartshow.setOption(&#123; //以下是echarts的数据 tooltip: &#123; trigger: &quot;item&quot;, formatter: &quot;&#123;a&#125; &lt;br/&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)&quot; &#125;, legend: &#123; orient: &quot;vertical&quot;, x: &quot;left&quot;, data: [ &quot;直达&quot;, &quot;营销广告&quot;, &quot;搜索引擎&quot;, &quot;邮件营销&quot;, &quot;联盟广告&quot;, &quot;视频广告&quot;, &quot;百度&quot;, &quot;谷歌&quot;, &quot;必应&quot;, &quot;其他&quot; ] &#125;, series: [ &#123; name: &quot;访问来源&quot;, type: &quot;pie&quot;, selectedMode: &quot;single&quot;, radius: [0, &quot;30%&quot;], label: &#123; normal: &#123; position: &quot;inner&quot; &#125; &#125;, labelLine: &#123; normal: &#123; show: false &#125; &#125;, data: [ &#123; value: 335, name: &quot;直达&quot;, selected: true &#125;, &#123; value: 679, name: &quot;营销广告&quot; &#125;, &#123; value: 1548, name: &quot;搜索引擎&quot; &#125; ] &#125;, &#123; name: &quot;访问来源&quot;, type: &quot;pie&quot;, radius: [&quot;40%&quot;, &quot;55%&quot;], label: &#123; normal: &#123; formatter: &quot;&#123;a|&#123;a&#125;&#125;&#123;abg|&#125;\n&#123;hr|&#125;\n &#123;b|&#123;b&#125;：&#125;&#123;c&#125; &#123;per|&#123;d&#125;%&#125; &quot;, backgroundColor: &quot;#eee&quot;, borderColor: &quot;#aaa&quot;, borderWidth: 1, borderRadius: 4, rich: &#123; a: &#123; color: &quot;#999&quot;, lineHeight: 22, align: &quot;center&quot; &#125;, hr: &#123; borderColor: &quot;#aaa&quot;, width: &quot;100%&quot;, borderWidth: 0.5, height: 0 &#125;, b: &#123; fontSize: 16, lineHeight: 33 &#125;, per: &#123; color: &quot;#eee&quot;, backgroundColor: &quot;#334455&quot;, padding: [2, 4], borderRadius: 2 &#125; &#125; &#125; &#125;, data: [ &#123; value: 335, name: &quot;直达&quot; &#125;, &#123; value: 310, name: &quot;邮件营销&quot; &#125;, &#123; value: 234, name: &quot;联盟广告&quot; &#125;, &#123; value: 135, name: &quot;视频广告&quot; &#125;, &#123; value: 1048, name: &quot;百度&quot; &#125;, &#123; value: 251, name: &quot;谷歌&quot; &#125;, &#123; value: 147, name: &quot;必应&quot; &#125;, &#123; value: 102, name: &quot;其他&quot; &#125; ] &#125; ] &#125;); &#125;, //数据结束 drawCharts() &#123; this.drawshowChart(); &#125; &#125;, //methods结束 mounted: function() &#123; this.drawCharts(); &#125;, updated: function() &#123; this.drawCharts(); &#125;&#125;;&lt;/script&gt;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F01%2F14%2FRegexp%2F</url>
    <content type="text"><![CDATA[字符\意义：对于字符，通常表示按字面意义，指出接着的字符为特殊字符，\不作解释。例如：/b/匹配字符’b’,通过在b 前面加一个反斜杠\，也就是/\b/，则该字符变成[特殊字符]表示匹配一个单词的分界线。或者：对于几个字符，通常说明是特殊的，指出紧接着的字符不是特殊的，而应该按字面解释。例如：是一个特殊字符，匹配任意个字符(包括0个字符)；例如：/a/意味匹配0个或多个a。为了匹配字面上的，在a前面加一个反斜杠；例如：/a\/匹配’a*’。 字符^意义：表示匹配的字符必须在最前边。例如：/^A/不匹配”an A,”中的’A’，但匹配”An A.”中最前面的’A’。 字符$意义：与^类似，匹配最末的字符。例如：/t$/不匹配”eater”中的’t’，但匹配”eat”中的’t’。 字符意义：匹配前面的字符0次或n次。例如:/bo*/匹配”A ghost booooed”中的’boooo’或”A bird warbled”中的’b’，但不匹配”A goat grunted”中的任何字符。 字符+意义：匹配+号前面的字符1次或n次。等价于{1,}。例如：/a+/匹配”candy”中的’a’和”caaaaaaandy.”中的所有’a’。 字符?意义：匹配?前面的字符0次或1次。例如：/e?le?/匹配”angel”中的’el’和”angle.”中的’le’。 字符.意义：(小数点)匹配除换行符外的所有单个的字符。例如：/.n/匹配”nay, an apple is on the tree”中的’an’和’on’，但不匹配’nay’。 字符(x)意义：匹配’x’并记录匹配的值。例如：/(foo)/匹配和记录”foo bar.”中的’foo’。匹配子串能被结果数组中的素[1], …, [n] 返回，或被RegExp对象的属性$1, …, $9返回。 字符x|y意义：匹配’x’或者’y’。例如：/green|red/匹配”green apple”中的’green’和”red apple.”中的’red’。 字符{n}意义：这里的n是一个正整数。匹配前面的n个字符。例如：/a{2}/不匹配”candy,”中的’a’，但匹配”caandy,” 中的所有’a’和”caaandy.”中前面的两个‘a’。 字符{n,}意义：这里的n是一个正整数。匹配至少n个前面的字符。例如：/a{2,}不匹配”candy”中的’a’，但匹配”caandy”中的所有’a’和”caaaaaaandy.”中的所有’a’ 字符{n,m}意义：这里的n和m都是正整数。匹配至少n个最多m个前面的字符。例如：/a{1,3}/不匹配”cndy”中的任何字符，但匹配 “candy,”中的’a’，”caandy,” 中的前面两个‘a’和”caaaaaaandy”中前面的三个’a’，注意：即使”caaaaaaandy” 中有很多个’a’，但只匹配前面的三个’a’即”aaa”。 字符[xyz]意义：一字符列表，匹配列出中的任一字符。你可以通过连字符-指出一个字符范围。例如：[abcd]跟[a-c]一样。它们匹配”brisket”中的’b’和”ache”中的’c’。 字符[^xyz]意义：一字符补集，也就是说，它匹配除了列出的字符外的所有东西。 你可以使用连字符-指出一字符范围。例如：[^abc]和[^a-c]等价，它们最早匹配”brisket”中的’r’和”chop.”中的’h’。 字符[\b]意义：匹配一个空格(不要与\b混淆) 字符\b意义：匹配一个单词的分界线，比如一个空格(不要与[\b]混淆)例如：/\bn\w/匹配”noonday”中的’no’，/\wy\b/匹配”possibly yesterday.”中的’ly’。 字符\B意义：匹配一个单词的非分界线例如：/\w\Bn/匹配”noonday”中的’on’，/y\B\w/匹配”possibly yesterday.”中的’ye’。 字符\cX意义：这里的X是一个[控制字符]。匹配一个字符串的[控制字符]例如：/\cM/匹配一个字符串中的control-M。 字符\d意义：匹配一个数字，等价于[0-9]。例如：/\d/或/[0-9]/匹配”B2 is the suite number.”中的’2’。 字符\D意义：匹配任何的非数字，等价于[^0-9]。例如：/\D/或/[^0-9]/匹配”B2 is the suite number.”中的’B’。 字符\f意义：匹配一个表单符 字符\n意义：匹配一个换行符 字符\r意义：匹配一个回车符 字符\s意义：匹配一个单个white空格符，包括空格，tab，form feed，换行符，等价于[ \f\n\r\t\v]。例如：/\s\w*/匹配”foo bar.”中的’ bar’。 字符\S意义：匹配除white空格符以外的一个单个的字符，等价于[^ \f\n\r\t\v]。例如：/\S/\w*匹配”foo bar.”中的’foo’。 字符\t意义：匹配一个制表符 字符\v意义：匹配一个顶头制表符 字符\w意义：匹配所有的数字和字母以及下划线，等价于[A-Za-z0-9_]。例如：/\w/匹配”apple,”中的’a’，”$5.28,”中的’5’和”3D.”中的’3’。 字符\W意义：匹配除数字、字母外及下划线外的其它字符，等价于[^A-Za-z0-9_]。例如：/\W/或者/[^$A-Za-z0-9_]/匹配”50%.”中的’%’。 字符\n意义：这里的n是一个正整数。匹配一个正则表达式的最后一个子串的n的值(计数左圆括号)。 例如：/apple(,)\sorange\1/匹配”apple, orange, cherry, peach.”中的’apple, orange’，下面有一个更加完整的例子。注意：如果左圆括号中的数字比\n指定的数字还小，则\n取下一行的八进制escape作为描述。 字符\ooctal和\xhex意义：这里的\ooctal是一个八进制的escape值，而\xhex是一个十六进制的escape值，允许在一个正则表达式中嵌入ASCII码。]]></content>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue组件之间传值]]></title>
    <url>%2F2018%2F12%2F05%2Fvuecomponent%2F</url>
    <content type="text"><![CDATA[父组件向子组件传值若父组件中的值value1:&#39;这是父组件中的值&#39;，要向子组件test传值。则在父组件中&lt;test v-bind:parentValue=&quot;value1&quot;&gt;&lt;/test&gt;上绑定自定义属性名（parentValue）的值为value1；子组件中data下定义props的值为父组件里自定义的属性名（parentValue），即：props:[&#39;parentValue&#39;]，然后在子组件中就可以通过parentValue传递父组件的值了。 子组件向父组件传递数据子组件主要通过事件传递数据给父组件,先在子组件中demo绑定事件（test），在methods中通过:123test:function()&#123; this.$emit(&apos;父组件中绑定的接收方法parentMethod&apos;,this.要传递的数据） &#125; 在父组件中通过&lt;demo v-on:parentMethod=&quot;自定义获取数据的方法getValue&quot;&gt;&lt;/demo&gt;，在父组件中methods里实现方法getValue(val){ this.value=val},其中里面的val是形参，再data中return接收到的数据value:&#39; &#39;，这时候就可以在父组件中使用value来传递子组件中的数据了。]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git（分布式版本控制系统）基本操作]]></title>
    <url>%2F2018%2F12%2F05%2Fgit%2F</url>
    <content type="text"><![CDATA[初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步：1.使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件；2.使用命令git commit -m &lt;message&gt;，完成。 git status命令可以让我们时刻掌握仓库当前的状态,用git diff这个命令看具体修改了什么内容。 提交修改和提交新文件是一样的两步，第一步是git add &lt;file&gt;,然后可以运行git status看看当前仓库的状态,第二步是git commit &lt;message&gt;。 用git log命令查看提交历史记录，commit后面表示版本号的id。 如何回到前面的版本：使用git reset --hard HEAD^命令，回到上一个版本。在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本可以写成HEAD~100；也可以通过$ git reset --hard &lt;版本号id&gt;，版本号id可以不用写全，写前面几位git会自动查找。 Git提供了一个命令git reflog用来记录你的每一次命令，可以查看commit提交信息和head版本id。 如果不用git add到暂存区，那就不会加入到commit中。 想直接丢弃工作区的修改时，用命令 git checkout -- &lt;file&gt;。 当文件添加到了暂存区，想丢弃修改时，第一步用命令git reset HEAD &lt;file&gt;，第二步用命令 git checkout -- &lt;file&gt;。 命令git rm &lt;file&gt;用于删除一个文件。 创建SSH Key:ssh-keygen -t rsa -C &quot;youremail@example.com&quot;，然后可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容，然后“Add Key”即可。本地仓库与GitHub仓库关联，使用git remote add origin +GitHub仓库ssh地址，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的。把本地库的内容推送到远程，用git push命令。第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令，git push -u origin master。 查看远程库信息，使用git remote -v。 创建分支：git branch &lt;name&gt;。 git branch命令列出所有分支，当前分支前面会标一个*号。 切换分支：git checkout &lt;name&gt;。 创建+切换分支：git checkout -b &lt;name&gt;。 合并某分支到当前分支：git merge &lt;name&gt;。 删除分支：git branch -d &lt;name&gt;。 git stash可以把当前工作现场“储藏”起来,git stash pop回到工作现场恢复的同时把stash内容也删了。 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。 git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id。 git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息。 git tag可以查看所有标签。 git push origin &lt;tagname&gt;可以推送一个本地标签。 git push origin --tags可以推送全部未推送过的本地标签 git tag -d &lt;tagname&gt;可以删除一个本地标签 git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax相关问题]]></title>
    <url>%2F2018%2F10%2F12%2Fajax%2F</url>
    <content type="text"><![CDATA[Ajax可以使网页实现异步更新，能够在不重新加载整个网页的情况下，对网页的某部分进行更新。就是利用JavaScript执行异步网络请求的方法。 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象，对于低版本的IE，需要用ActiveXObject对象。 如果想把标准写法和IE写法混在一起，可以这么写:123456 var request; if (window.XMLHttpRequest) &#123; request = new XMLHttpRequest(); &#125; else &#123; request = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);&#125; jQuery中封装了ajax操作：$.ajax()属于最底层的方法（接收的参数）；1.url:要求为String类型的参数，（默认为当前页地址）发送请求的地址。 2.type:要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。 3.timeout:要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。 4.async:要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。 5.cache:要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。 6.data:要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看 processData选项。对象必须为key/value格式，例如{foo1:”bar1”,foo2:”bar2”}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[“bar1”,”bar2”]}转换为&amp;foo=bar1&amp;foo=bar2。 7.dataType:要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：xml：返回XML文档，可用JQuery处理。html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。json：返回JSON数据。jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。text：返回纯文本字符串。 8.beforeSend：要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。123function(XMLHttpRequest)&#123; this; //调用本次ajax请求时传递的options参数 &#125; 9.complete：要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。123function(XMLHttpRequest, textStatus)&#123; this; //调用本次ajax请求时传递的options参数 &#125; 10.success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。 (1)由服务器返回，并根据dataType参数进行处理后的数据。 (2)描述状态的字符串。1234function(data, textStatus)&#123; //data可能是xmlDoc、jsonObj、html、text等等 this; //调用本次ajax请求时传递的options参数 &#125; 11.error:要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下：1234function(XMLHttpRequest, textStatus, errorThrown)&#123; //通常情况下textStatus和errorThrown只有其中一个包含信息 this; //调用本次ajax请求时传递的options参数 &#125; 12.contentType：要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为”application/x-www-form-urlencoded”。该默认值适合大多数应用场合。 13.dataFilter：要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。1234function(data, type)&#123; //返回处理后的数据 return data; &#125; 14.dataFilter：要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。1234function(data, type)&#123; //返回处理后的数据 return data; &#125; 15.global：要求为Boolean类型的参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件。 16.ifModified：要求为Boolean类型的参数，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息。 17.jsonp：要求为String类型的参数，在一个jsonp请求中重写回调函数的名字。该值用来替代在”callback=?”这种GET或POST请求中URL参数里的”callback”部分，例如{jsonp:’onJsonPLoad’}会导致将”onJsonPLoad=?”传给服务器。 18.username：要求为String类型的参数，用于响应HTTP访问认证请求的用户名。 19.password：要求为String类型的参数，用于响应HTTP访问认证请求的密码。 20.processData：要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型”application/x-www-form-urlencoded”。如果要发送DOM树信息或者其他不希望转换的信息，请设置为false。 21.scriptCharset：要求为String类型的参数，只有当请求时dataType为”jsonp”或者”script”，并且type是GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。 load(),$.get(),$.post()属于第二层方法(接收参数）； load(url,[data].callback)；$.get(url,[data],callback,type)//post方法参数相同 $.getScript(),$.getJson()属于第三层方法(接收参数）。123456$(function()&#123; $(&quot;test&quot;).click(function()&#123; $.getScript(&apos;test.js&apos;); &#125;);&#125;)$.getJson()参数相同 Ajax跨域问题 Ajax跨域问题是因为浏览器的同源策略导致的，默认情况下，JavaScript在发送AJAX请求时，URL的域名要相同，协议要相同，端口号要相同必须和当前页面完全一致。 解决办法JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监听移动端滑动事件]]></title>
    <url>%2F2018%2F10%2F06%2Fmobile%20slide%2F</url>
    <content type="text"><![CDATA[监听用户滑动事件1234567891011121314151617181920212223242526272829var mybody = document.getElementsByTagName(&apos;body&apos;)[0]; var startX, startY, moveEndX, moveEndY, X, Y; mybody.addEventListener(&apos;touchstart&apos;, function (e) &#123; // e.preventDefault(); startX = e.touches[0].pageX; startY = e.touches[0].pageY; &#125;, false); mybody.addEventListener(&apos;touchmove&apos;, function (e) &#123; // e.preventDefault(); moveEndX = e.changedTouches[0].pageX; moveEndY = e.changedTouches[0].pageY; X = moveEndX - startX; Y = moveEndY - startY; if (Math.abs(X) &gt; Math.abs(Y) &amp;&amp; X &gt; 0) &#123;// right alert(&apos;向右&apos;); &#125; else if (Math.abs(X) &gt; Math.abs(Y) &amp;&amp; X &lt; 0) &#123;// left alert(&apos;向左&apos;); &#125; else if (Math.abs(Y) &gt; Math.abs(X) &amp;&amp; Y &gt; 0) &#123;// down alert(&apos;向下&apos;); &#125; else if (Math.abs(Y) &gt; Math.abs(X) &amp;&amp; Y &lt; 0) &#123;// up alert(&apos;向上&apos;); &#125; else &#123;//没有发生滑动 alert(&apos;没有发生滑动&apos;); &#125; &#125;); 主要是通过touchstart和touchmove来监听用户滑动，再通过滑动的起始坐标作差的绝对值来判断是向哪个方向滑动。]]></content>
  </entry>
  <entry>
    <title><![CDATA[清除浮动的几种方式]]></title>
    <url>%2F2018%2F09%2F04%2Ffloat%2F</url>
    <content type="text"><![CDATA[说到清除浮动之前，得先了解下BFC (Block formatting context) “块级格式化上下文”，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用， 在进行盒子元素布局的时候，BFC提供了一个环境，在这个环境中按照一定规则进行布局不会影响到其它环境中的布局。如果一个元素符合了成为BFC的条件，该元素内部元素的布局和定位就和外部元素互不影响(除非内部的盒子建立了新的 BFC)，是一个隔离了的独立容器，它是一个独立的渲染区域。 形成 BFC 的条件1、浮动元素，float 除 none 以外的值；2、绝对定位元素，position（absolute，fixed）；3、display 为以下其中之一的值 inline-blocks，table-cells，table-captions；4、overflow 除了 visible 以外的值（hidden，auto，scroll）。 BFC常见作用 ： 1、包含浮动元素例如：高度塌陷问题：在通常情况下父元素的高度会被子元素撑开，而在这里因为其子元素为浮动元素所以父元素发生了高度坍塌，上下边界重合。这时就可以用bfc来清除浮动了。2、不被浮动元素覆盖例如： div浮动兄弟遮盖问题：由于一个块级元素发生了浮动，所以和一个未发生浮动的块级元素不在同一层内，所以会发生div遮挡问题。这时可以给未发生浮动的元素添加 overflow: hidden属性来触发BFC解决遮挡问题。3、 BFC 会阻止外边距折叠例如：margin塌陷问题：在标准文档流中，块级标签之间竖直方向的margin会以大的为准，这就是margin的塌陷现象。可以用overflow：hidden产生bfc来解决。 清除浮动的几种方式：1、父级div定义伪类：after和zoom。12.clearfloat:after&#123;display:block;clear:both;content:&quot;&quot;;visibility:hidden;height:0&#125; .clearfloat&#123;zoom:1&#125; 2.给元素添加clear属性，或在结尾处添加空div标签clear:both（内墙法，外墙法同理）。.clearfloat{clear:both}3.父级div定义height（只适合高度固定的布局，要给出精确的高度）。4.父级div定义overflow:hidden/auto，*zoom: 1。5.设置父元素浮动 。6.双伪元素（企业最常用）。12.cf:after，.cf:before &#123;content: &quot; &quot;; display: table;&#125;.cf:after &#123;clear: both;&#125; ：before是因为table类型能生成独立的bfc，防止上边距塌陷。：after负责清除浮动，防止父级高度塌陷；配合使用，代码少，效率高。]]></content>
      <tags>
        <tag>float</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+github搭建博客遇到的一些问题]]></title>
    <url>%2F2018%2F08%2F26%2Ftest%2F</url>
    <content type="text"><![CDATA[个人头像的设置问题 官方文档是这样描述的:将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在) 配置为：avatar: /uploads/avatar.png 或者 放置在 source/images/ 目录下 配置为：avatar: /images/avatar.png 而这样设置，头像却显示不出来，原来是要在站点目录的source下创建uploads文件夹，将图片放在uploads下并命名为avatar.png，然后再设置站点配置文件-config.yml，在任意位置添加avatar: /upload/image/avatar.png并保存。 添加评论系统 我使用了来必力免费的city版本，因为它支持10多种账号登录发布评论，在新版nexT主题中只需编辑主题配置文件，编辑来必力中提供的uid添加到livere-uid字段livere-uid: #your livere_uid即可。而此系统在博文前不能显示评论数量，在nexT中多个评论系统是相互冲突的，只能设置一个。最后，如需取消某个页面/文章的评论，在md文件中增加 comments: false即可。 Hexo常用快捷键 hexo clean 清除缓存 hexo n “your post name” == hexo new “your post name” 新建博文 hexo g == hexo generate 生成静态文件 hexo s == hexo server 运行hexo服务器 hexo d == hexo deploy 部署到云端]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
